//! This example shows how to use the DAC on PIN 25 and 26
//! You can connect an LED (with a suitable resistor) or check the changing
//! voltage using a voltmeter on those pins.

//#![feature(restricted_std)]
#![no_std]
#![no_main]
#![feature(type_alias_impl_trait)]

use core::{cell::RefCell, ops::BitOr};

use critical_section::Mutex;

use esp_backtrace as _;
use esp_println::println;

use esp32_hal::{
    cpu_control::{CpuControl, Stack},
    clock::ClockControl,
    interrupt,
    interrupt::Priority,
    peripherals::{self, Peripherals, TIMG0, TIMG1},
    prelude::*,
    timer::{Timer, Timer0, Timer1, TimerGroup},
    dac, gpio::IO, prelude::*, Delay,
    dac::DAC1,
    dac::DAC,
    psram,
    embassy::{self, executor::Executor},
};

use embassy_executor::{Spawner};
use embassy_sync::{blocking_mutex::raw::CriticalSectionRawMutex, signal::Signal, channel::Channel};
use embassy_time::{Duration, Ticker, Instant};

use log::{error, warn, info, debug};

use static_cell::make_static;

static TIMER10: Mutex<RefCell<Option<Timer<Timer0<TIMG1>>>>> = Mutex::new(RefCell::new(None));
static DAC_PIN_1: Mutex<RefCell<Option<DAC1<esp32_hal::analog::DAC1>>>> = Mutex::new(RefCell::new(None));

//const DATA_LEN: usize = 256;
//static mut DATA: [u8; DATA_LEN] = [0; DATA_LEN];
static mut DATA_I: usize = 0;
static mut CNT: u64 = 0;

// Allocator
extern crate alloc;

#[global_allocator]
static ALLOCATOR: esp_alloc::EspHeap = esp_alloc::EspHeap::empty();

const ALLOCATOR_MEM_SIZE: usize = 16_000;
static ALLOCATOR_MEM: core::mem::MaybeUninit<[u8; ALLOCATOR_MEM_SIZE]> = core::mem::MaybeUninit::uninit();

#[embassy_executor::task]
async fn task1() {
    let mut ticker = Ticker::every(Duration::from_secs(1));
    loop {
        info!("test1");
        ticker.next().await;
    }
}

struct AudioPacket {
    samples: alloc::boxed::Box<heapless::Vec<u8, 1024>>,
    sample_rate: u32,
}

const PacketQueueSize: usize = 4;

static AudioChannel_1: Channel<CriticalSectionRawMutex, AudioPacket, PacketQueueSize> = Channel::new();
// static AudioChannelRecycle: Channel<CriticalSectionRawMutex, AudioPacket, PacketQueueSize> = Channel::new();

static AudioChannel: Mutex<RefCell<heapless::Vec<AudioPacket, PacketQueueSize>>> =
    Mutex::new(RefCell::new(heapless::Vec::<AudioPacket, PacketQueueSize>::new()));
static AudioChannelRecycle: Mutex<RefCell<heapless::Vec<AudioPacket, PacketQueueSize>>> =
    Mutex::new(RefCell::new(heapless::Vec::<AudioPacket, PacketQueueSize>::new()));

use ringbuffer::RingBuffer;
static mut a_buf: ringbuffer::ConstGenericRingBuffer<u8, 5000> = ringbuffer::ConstGenericRingBuffer::new();

#[embassy_executor::task]
async fn decoder() {
    
    let MP3_DATA  = include_bytes!("../test.mp3");
    println!("len1 {}", MP3_DATA.len());

    use rmp3::{Decoder, Frame};

    loop {
        let mut decoder = Decoder::new(MP3_DATA);
        
        while let Some(frame) = decoder.next() {
            if let Frame::Audio(audio) = frame {
                println!("frame");

                loop {
                    // let free =
                    // unsafe {
                            // if audio_buffer.reader_pos.assume_init() > audio_buffer.writer_pos.assume_init() {
                                // audio_buffer.reader_pos.assume_init() - audio_buffer.writer_pos.assume_init()
                            // } else {
                                // (audio_buffer.buf.len() - audio_buffer.writer_pos.assume_init()) + audio_buffer.reader_pos.assume_init()
                            // }
                    // };
                    let free = unsafe { a_buf.capacity() - a_buf.len() };
                    unsafe { assert_eq!(a_buf.capacity(), 5000); }
                    if free <= 1024 {
                        info!("Decode wait");
                        // let mut vec = 0;
                        // for i in 0..10_000_000 {
                        //     vec += 1;
                        // }
                    } else {
                        break;
                    }
                }
                
                //println!("{} {} {} {}", audio.bitrate(), audio.sample_count(), audio.sample_rate(), audio.channels());
                let samples = audio.samples();
                let channels = audio.channels() as usize;
                let sample_count = audio.sample_count();

                info!("CCC");
                // let mut packet = AudioChannelRecycle.receive().await;
                
                info!("ACC");
                // let mut packet = {
                //     let mut packet: Option<AudioPacket> = None;
                //     while let None = packet {
                //         packet = critical_section::with(|cs| AudioChannelRecycle.borrow_ref_mut(cs).pop());
                //     }
                //     packet.unwrap()
                // };
                // info!("ACC1");

                // packet.sample_rate = audio.sample_rate();
                // packet.samples.clear();

                // for i in 0..sample_count {
                //     packet.samples.push((samples[i * channels]  / 256 + 127) as u8);
                // }
                // info!("DDD");

                // // AudioChannel.send(packet).await;
                // critical_section::with(|cs| {
                //     AudioChannel.borrow_ref_mut(cs).push(packet);
                // });

                // let writer_pos = unsafe { audio_buffer.writer_pos.assume_init() };
                // for i in 0..sample_count {
                //     let sample = (samples[i * channels] / 256 + 127) as u8;
                //     unsafe { audio_buffer.buf[writer_pos] = sample };
                //     writer_pos += 1;
                //     if writer_pos >= unsafe { audio_buffer.buf.len() } {
                //         writer_pos = 0;
                //     }
                // }
                // unsafe { audio_buffer.writer_pos.write(writer_pos) };
                for i in 0..sample_count {
                    let sample = (samples[i * channels] / 256 + 127) as u8;
                    unsafe { a_buf.push(sample) };
                }

                info!("EEE");
            }
        }
        info!("END OF FILE");
    }
}

#[main]
async fn main(_spawner: Spawner) -> ! {
    esp_println::logger::init_logger(log::LevelFilter::Debug);

    unsafe { ALLOCATOR.init(&mut ALLOCATOR_MEM.assume_init()[0] as *mut u8, ALLOCATOR_MEM_SIZE) };
    
    /*unsafe {
        DATA = {
            use micromath::{F32, F32Ext};
            core::array::from_fn(|i| {
                (f32::sin(i as f32 / (DATA_LEN - 1) as f32 * core::f32::consts::TAU) * (u8::MAX / 2) as f32 + (u8::MAX / 2) as f32) as u8
            })
        };
    };*/
    //let DATA_LEN = data_len;
    //let DATA = data[0..data_len];
    /*let data: [u8; DATA_LEN] = {
        use micromath::{F32, F32Ext};
        core::array::from_fn(|i| {
            (f32::sin(i as f32 / DATA_LEN as f32 * core::f32::consts::TAU)* (u8::MAX / 2) as f32 + (u8::MAX / 2) as f32) as u8
        })
    };*/

    let peripherals = Peripherals::take();
    let system = peripherals.SYSTEM.split();

    /*
    let mut dec: heapless::Vec<u8, 500_000> = (0..500_000).map(|_| 0u8).collect();
    for (i, e) in dec.iter_mut().enumerate() {
        *e = 10;
    }
    println!("{:?}", dec);
    */
    

    let clocks = ClockControl::boot_defaults(system.clock_control).freeze();

    let io = IO::new(peripherals.GPIO, peripherals.IO_MUX);
    let pin25 = io.pins.gpio25.into_analog();
    let pin26 = io.pins.gpio26.into_analog();

    let timer_group0 = esp32_hal::timer::TimerGroup::new(peripherals.TIMG0, &clocks);
    esp32_hal::embassy::init(&clocks, timer_group0.timer0);

    // Go multicore
    let mut cpu_control = CpuControl::new(system.cpu_control);
    
    let cpu1_fnctn = move || {
        let executor = make_static!(Executor::new());
        executor.run(|spawner| {
            spawner.spawn(decoder()).ok();
        });
    };

    let APP_CORE_STACK: &mut Stack<8192> = make_static!(Stack::new());

    let _guard = cpu_control
        .start_app_core(unsafe { APP_CORE_STACK }, cpu1_fnctn)
        .unwrap();
    info!("123123");
/*
    let mut ticker = Ticker::every(Duration::from_secs(2));
    loop {
        info!("main");
        ticker.next().await;
    }*/
/*
    let mut delay = Delay::new(&clocks);
    loop {
        info!("main");
        delay.delay_ms(1000u32);
    }
*/

    let mut rtc = esp32_hal::Rtc::new(peripherals.RTC_CNTL);

    let timer_group1 = TimerGroup::new(peripherals.TIMG1, &clocks);
    let mut timer10 = timer_group1.timer0;
    let mut timer11 = timer_group1.timer1;


    //interrupt::enable(peripherals::Interrupt::TG1_T0_LEVEL, Priority::Priority2).unwrap();

    timer10.start(2u64.secs());
    timer10.listen();
    let mut d = Delay::new(&clocks);
/*
    let mut l1 = 0;
    let mut t = embassy_time::Instant::now();

    loop {
        let _l1 = timer10.now();
        let el = _l1 - l1;
        let t1 = t.elapsed();
        t = embassy_time::Instant::now();
        l1 = _l1;
        println!("{} {}", el, t1.as_micros());
        d.delay_ms(5u32);
    }

    timer10.start(2u64.secs());
    timer10.listen();

*/
    let analog = peripherals.SENS.split();
    let mut dac1: DAC1<esp32_hal::analog::DAC1> = dac::DAC1::dac(analog.dac1, pin25).unwrap();

    println!("{}", timer10.divider());

    //let dec: &[u8] = include_bytes!("../test1.raw");
    //let r = dec.len();

    //println!("{data:?}");
    /*
    loop {
        dac1.write(data[cnt]);
        cnt += 1;
        if cnt >= DATA_LEN {
            cnt = 0; 
        } else {
            cnt = cnt;
        }
        d.delay_us(10u32);
    }
    */

        // AudioChannelRecycle.send(AudioPacket {
        //     sample_rate: 0,
        //     samples: alloc::boxed::Box::new(heapless::Vec::<u8, 1024>::new()),
        // }).await;
    info!("PRE0");
    // critical_section::with(|cs| {
    //     let mut v = AudioChannelRecycle.borrow_ref_mut(cs);
    //     for i in 0..PacketQueueSize {
    //         info!("PRE");
    //         v.push(AudioPacket {
    //             sample_rate: 0,
    //             samples: alloc::boxed::Box::new(heapless::Vec::<u8, 1024>::new()),
    //         });
    //     }
    // });

    // for _ in 0..10 {
    //     let mut l11 = timer10.now();
    //     AudioChannel_1.send(AudioPacket {
    //         sample_rate: 0,
    //         samples: alloc::boxed::Box::new(heapless::Vec::<u8, 1024>::new()),
    //     }).await;
    //     let mut l21 = timer10.now();
    //     debug!("l11 l21 {}", l21 - l11);
    //     let mut l12 = timer10.now();
    //     AudioChannel_1.receive().await;
    //     let mut l22 = timer10.now();
    //     debug!("l12 l22 {}", l22 - l12);
    // }
    // for _ in 0..10 {
    //     let mut l1 = timer10.now();
    //     critical_section::with(|cs| AudioChannelRecycle.borrow_ref_mut(cs).pop());
    //     let mut l2 = timer10.now();
    //     debug!("l1 l2 {}", l2 - l1);
    // }
    // info!("AAA");
    // let mut audio_packet = AudioChannel.receive().await;
    // let mut audio_packet = {
    //     let mut packet: Option<AudioPacket> = None;
    //     while let None = packet {
    //         let packet = critical_section::with(|cs| AudioChannel.borrow_ref_mut(cs).pop());
    //     }
    //     packet.unwrap()
    // };
    // let mut slice: &[u8] = &audio_packet.samples[..];
    info!("BBB");

    //Ticker::every(Duration::from_millis(1000u64)).next().await;
    // unsafe { audio_buffer.reader_pos.write(0) };

    let ticks_per_second = 40_000_000;
    // let mut ticks_per_sample = (ticks_per_second / audio_packet.sample_rate) as u64;
    let mut ticks_per_sample = (ticks_per_second / 48_000) as u64;


    let mut cnt = 0;
    let mut last = timer10.now();
    loop {
        // if slice.len() == 0 {
        //     // AudioChannelRecycle.send(audio_packet).await;
        //     // audio_packet = AudioChannel.receive().await;

        //     // critical_section::with(|cs| {
        //     //     AudioChannelRecycle.borrow_ref_mut(cs).push(audio_packet);
        //     // });

        //     audio_packet = {
        //         let mut packet: Option<AudioPacket> = None;
        //         while let None = packet {
        //             let packet = critical_section::with(|cs| AudioChannel.borrow_ref_mut(cs).pop());
        //         }
        //         packet.unwrap()
        //     };

        //     slice = &audio_packet.samples[..];

        //     ticks_per_sample = (ticks_per_second / audio_packet.sample_rate) as u64;
        // }
        let now: u64 = timer10.now();
        let dt: u64 = match now.checked_sub(last) {
            Some(dt) => dt,
            None => (u64::MAX - last) + now,
        };// ticks_per_second / 48_000;

        if dt >= ticks_per_sample {
            //last = now.wrapping_sub(dt - ticks_per_sample);
            last = now;
            // let sample =
            //     if cnt + 1 < DATA_LEN {
            //         i16::from_be_bytes([ data[cnt], data[cnt+1] ])
            //     } else {
            //         data[cnt] as i16
            //     };
            // let sample = slice[0];
            let mut sample = None;
            while let None = sample {
                sample = unsafe { a_buf.front() };
                // println!("Await");
            }
            let sample = *sample.unwrap();

            // dac1.write(unsafe {audio_buffer.buf[reader_pos]});
            dac1.write(sample);

            
            //println!("{l5}");
            let skip = (dt / ticks_per_sample) as usize;
            if dt > ticks_per_sample + 50000 {
                //println!("TOO LONG!!! : {dt} : {ticks_per_sample} :");
            }
            for _ in 0..skip {
                unsafe { a_buf.skip() };
            }
            // reader_pos += skip;
            // if reader_pos >= unsafe { audio_buffer.buf.len() } {
            //     reader_pos = reader_pos % unsafe { audio_buffer.buf.len() };
            // }
            //println!("{reader_pos}");

            // unsafe { audio_buffer.reader_pos.write(reader_pos) };

            // if skip != 1 {
            //     //println!("{}", skip);
            // }

            // if slice.len() > skip {
                
            //     slice = &slice[skip..];
            // } else {
            //     slice = &[];
            // }
        }
    }

    critical_section::with(|cs| {
        TIMER10.borrow_ref_mut(cs).replace(timer10);
        DAC_PIN_1.borrow_ref_mut(cs).replace(dac1);
        //DATA.borrow_ref_mut(cs).replace(data);
    });
    loop {}

}

/*

#[interrupt]
fn TG1_T0_LEVEL() {
    critical_section::with(|cs| {
unsafe {
    DAC_PIN_1.borrow_ref_mut(cs).as_mut().unwrap().write(DATA[DATA_I]);
};
    unsafe { DATA_I += 1;
    if DATA_I == DATA_LEN {
        unsafe { DATA_I = 0 };
    }};

        let mut timer = TIMER10.borrow_ref_mut(cs);
        let timer = timer.as_mut().unwrap();

        if timer.is_interrupt_set() {
            timer.clear_interrupt();
            timer.start(1u64.micros());

            unsafe {
                CNT += 1;
                if CNT > 100_000 {
                    CNT = 0;
                    esp_println::println!("Interrupt Level 3 - Timer0");
                }
            }
        }
    });
}
*/