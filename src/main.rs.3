//! This example shows how to use the DAC on PIN 25 and 26
//! You can connect an LED (with a suitable resistor) or check the changing
//! voltage using a voltmeter on those pins.

//#![feature(restricted_std)]
#![no_std]
#![no_main]
#![feature(type_alias_impl_trait)]

use core::{cell::RefCell, ops::BitOr};

use critical_section::Mutex;

use esp_backtrace as _;
use esp_println::println;

use esp32_hal::{
    cpu_control::{CpuControl, Stack},
    clock::ClockControl,
    interrupt,
    interrupt::Priority,
    peripherals::{self, Peripherals, TIMG0, TIMG1},
    prelude::*,
    timer::{Timer, Timer0, Timer1, TimerGroup},
    dac, gpio::IO, prelude::*, Delay,
    dac::DAC1,
    dac::DAC,
    psram,
    embassy::{self, executor::Executor},
    ledc,
};

use embassy_executor::{Spawner};
use embassy_sync::{blocking_mutex::raw::CriticalSectionRawMutex, signal::Signal, channel::Channel};
use embassy_time::{Duration, Ticker, Instant};

use log::{error, warn, info, debug};

use static_cell::make_static;

// Allocator
extern crate alloc;

#[global_allocator]
static ALLOCATOR: esp_alloc::EspHeap = esp_alloc::EspHeap::empty();

const ALLOCATOR_MEM_SIZE: usize = 80_000;
static ALLOCATOR_MEM: core::mem::MaybeUninit<[u8; ALLOCATOR_MEM_SIZE]> = core::mem::MaybeUninit::uninit();


// Audio packeting
const PacketQueueSize: usize = 4;
const PacketSampleslen: usize = 8_000;

struct AudioPacket {
    samples: alloc::boxed::Box<heapless::Vec<u8, PacketSampleslen>>,
    sample_rate: u32,
}

static AudioChannel: Channel<CriticalSectionRawMutex, AudioPacket, PacketQueueSize> = Channel::new();
static AudioChannelRecycle: Channel<CriticalSectionRawMutex, AudioPacket, PacketQueueSize> = Channel::new();

#[embassy_executor::task]
async fn decoder() {
    
    let MP3_DATA  = include_bytes!("../b1.mp3");
    println!("len1 {}", MP3_DATA.len());

    use rmp3::{Decoder, Frame};

    let mut packet = AudioChannelRecycle.receive().await;
    packet.samples.clear();

    loop {
        let mut decoder = Decoder::new(MP3_DATA);
        
        while let Some(frame) = decoder.next() {
            if let Frame::Audio(audio) = frame {
                //println!("{} {} {} {}", audio.bitrate(), audio.sample_count(), audio.sample_rate(), audio.channels());
                let samples = audio.samples();
                let channels = audio.channels() as usize;
                let sample_count = audio.sample_count();

                packet.sample_rate = audio.sample_rate();

                for i in 0..sample_count {
                    //packet.samples.push((samples[i * channels]  / 256 + 127) as u8);
                    packet.samples.push((samples[i * channels] as i16 / 256 + 128) as u8);
                    if packet.samples.is_full() {
                        AudioChannel.send(packet).await;
                        packet = AudioChannelRecycle.receive().await;
                        packet.samples.clear();
                    }
                }
            }
        }
        info!("END OF FILE");
    }
}

#[main]
async fn main(_spawner: Spawner) -> ! {
    // Logger
    esp_println::logger::init_logger(log::LevelFilter::Debug);

    // Allocator
    unsafe { ALLOCATOR.init(&mut ALLOCATOR_MEM.assume_init()[0] as *mut u8, ALLOCATOR_MEM_SIZE) };

    // Post-boot setup
    let peripherals = Peripherals::take();
    let system = peripherals.SYSTEM.split();

    let clocks = ClockControl::boot_defaults(system.clock_control).freeze();

    // Set up IO pins
    let io = IO::new(peripherals.GPIO, peripherals.IO_MUX);
    let pin25 = io.pins.gpio25.into_analog();
    let pin26 = io.pins.gpio26.into_analog();
    let led = io.pins.gpio14.into_push_pull_output(); // ledc

    // Set up embassy
    let timer_group0 = esp32_hal::timer::TimerGroup::new(peripherals.TIMG0, &clocks);
    esp32_hal::embassy::init(&clocks, timer_group0.timer0);

    // Go multicore
    let mut cpu_control = CpuControl::new(system.cpu_control);
    
    let cpu1_fnctn = move || {
        let executor = make_static!(Executor::new());
        executor.run(|spawner| {
            spawner.spawn(decoder()).ok();
        });
    };

    let APP_CORE_STACK: &mut Stack<8192> = make_static!(Stack::new());

    let _guard = cpu_control
        .start_app_core(unsafe { APP_CORE_STACK }, cpu1_fnctn)
        .unwrap();
    info!("123123");
    

    let mut rtc = esp32_hal::Rtc::new(peripherals.RTC_CNTL);

    let timer_group1 = TimerGroup::new(peripherals.TIMG1, &clocks);
    let mut timer10 = timer_group1.timer0;
    let mut timer11 = timer_group1.timer1;


    //interrupt::enable(peripherals::Interrupt::TG1_T0_LEVEL, Priority::Priority2).unwrap();

    timer10.start(2u64.secs());
    timer10.listen();
    let mut d = Delay::new(&clocks);
/*
    let mut l1 = 0;
    let mut t = embassy_time::Instant::now();

    loop {
        let _l1 = timer10.now();
        let el = _l1 - l1;
        let t1 = t.elapsed();
        t = embassy_time::Instant::now();
        l1 = _l1;
        println!("{} {}", el, t1.as_micros());
        d.delay_ms(5u32);
    }

    timer10.start(2u64.secs());
    timer10.listen();

*/
    let analog = peripherals.SENS.split();
    let mut dac1: DAC1<esp32_hal::analog::DAC1> = dac::DAC1::dac(analog.dac1, pin25).unwrap();
    use esp32_hal::ledc::Speed;
    let ledc = esp32_hal::ledc::LEDC::new(peripherals.LEDC, &clocks);
    let mut hstimer0 = ledc.get_timer::<ledc::HighSpeed>(ledc::timer::Number::Timer0);

    let pwm_freq = 100_000u32;

    hstimer0
        .configure(ledc::timer::config::Config {
            duty: ledc::timer::config::Duty::Duty8Bit,
            clock_source: ledc::timer::HSClockSource::APBClk,
            frequency: pwm_freq.Hz(),
        })
        .unwrap();


    let mut channel0 = ledc.get_channel(ledc::channel::Number::Channel0, led);
    channel0
        .configure(ledc::channel::config::Config {
            timer: &hstimer0,
            duty_pct: 10,
            pin_config: ledc::channel::config::PinConfig::PushPull,
        })
        .unwrap();

    // loop {
    //     // Set up a breathing LED: fade from off to on over a second, then
    //     // from on back off over the next second.  Then loop.
    //     channel0.start_duty_fade(0, 100, 1000).unwrap();
    //     while channel0.is_duty_fade_running() {}
    //     channel0.start_duty_fade(100, 0, 1000).unwrap();
    //     while channel0.is_duty_fade_running() {}
    // }

    println!("{}", timer10.divider());

    //let dec: &[u8] = include_bytes!("../test1.raw");
    //let r = dec.len();

    //println!("{data:?}");
    /*
    loop {
        dac1.write(data[cnt]);
        cnt += 1;
        if cnt >= DATA_LEN {
            cnt = 0; 
        } else {
            cnt = cnt;
        }
        d.delay_us(10u32);
    }
    */
    for _ in 0..PacketQueueSize {
        AudioChannelRecycle.send(AudioPacket {
            sample_rate: 0,
            samples: alloc::boxed::Box::new(heapless::Vec::<u8, PacketSampleslen>::new()),
        }).await;
    }
    info!("PRE0");
    // critical_section::with(|cs| {
    //     let mut v = AudioChannelRecycle.borrow_ref_mut(cs);
    //     for i in 0..PacketQueueSize {
    //         info!("PRE");
    //         v.push(AudioPacket {
    //             sample_rate: 0,
    //             samples: alloc::boxed::Box::new(heapless::Vec::<u8, 1024>::new()),
    //         });
    //     }
    // });

    // for _ in 0..10 {
    //     let mut l11 = timer10.now();
    //     AudioChannel_1.send(AudioPacket {
    //         sample_rate: 0,
    //         samples: alloc::boxed::Box::new(heapless::Vec::<u8, 1024>::new()),
    //     }).await;
    //     let mut l21 = timer10.now();
    //     debug!("l11 l21 {}", l21 - l11);
    //     let mut l12 = timer10.now();
    //     AudioChannel_1.receive().await;
    //     let mut l22 = timer10.now();
    //     debug!("l12 l22 {}", l22 - l12);
    // }
    // for _ in 0..10 {
    //     let mut l1 = timer10.now();
    //     critical_section::with(|cs| AudioChannelRecycle.borrow_ref_mut(cs).pop());
    //     let mut l2 = timer10.now();
    //     debug!("l1 l2 {}", l2 - l1);
    // }
    // info!("AAA");
    // let mut audio_packet = {
    //     let mut packet: Option<AudioPacket> = None;
    //     while let None = packet {
    //         let packet = critical_section::with(|cs| AudioChannel.borrow_ref_mut(cs).pop());
    //     }
    //     packet.unwrap()
    // };

    let mut audio_packet = AudioChannel.receive().await;
    let mut slice = &audio_packet.samples[..];
    info!("BBB");

    //Ticker::every(Duration::from_millis(1000u64)).next().await;
    // unsafe { audio_buffer.reader_pos.write(0) };

    let ticks_per_second = 40_000_000;
    // let mut ticks_per_sample = (ticks_per_second / audio_packet.sample_rate) as u64;
    let mut ticks_per_sample = (ticks_per_second / audio_packet.sample_rate) as u64;


    let mut last = timer10.now();
    loop {
        if slice.len() == 0 {
            // TODO: Add benchmarking
            AudioChannelRecycle.send(audio_packet).await;
            audio_packet = AudioChannel.receive().await;

            slice = &audio_packet.samples[..];
            ticks_per_sample = (ticks_per_second / audio_packet.sample_rate) as u64;
        }

        let now: u64 = timer10.now();
        let dt: u64 = match now.checked_sub(last) {
            Some(dt) => dt,
            None => (u64::MAX - last) + now,
        };

        if dt >= ticks_per_sample {
            //last = now.wrapping_sub(dt - ticks_per_sample);
            last = now;
            // let sample =
            //     if cnt + 1 < DATA_LEN {
            //         i16::from_be_bytes([ data[cnt], data[cnt+1] ])
            //     } else {
            //         data[cnt] as i16
            //     };
            let sample = slice[0];
            
            dac1.write(sample);

            
            
            // channel0.set_duty_hw(((sample as u32)));
            // if slice.len() != 1 {
            //     let next_sample = slice[1];
            //     let diff: u16 = next_sample.abs_diff(sample) as u16;
            //     if diff != 0 {
            //         let pwm_ticks = (pwm_freq * ticks_per_sample as u32 / ticks_per_second).min(u16::MAX as u32) as u16;
            //         let cycles_per_step = (pwm_ticks / diff).max(1);
            //         let duty_per_cycle = (diff / pwm_ticks).max(1);
            //         let duty_steps = diff / duty_per_cycle;
            //         // println!("{sample} {next_sample} {pwm_ticks} {cycles_per_step} {} {duty_per_cycle} {duty_steps}", next_sample > sample);
            //         channel0.start_duty_fade_hw(sample as u32, next_sample > sample, duty_steps, cycles_per_step, duty_per_cycle)
            //     }
            // }

            let skip = (dt / ticks_per_sample) as usize;

            if dt > ticks_per_sample + 50000 {
                println!("TOO LONG!!! : {dt} : {ticks_per_sample} :");
            }

            if slice.len() > skip {
                slice = &slice[skip..];
            } else {
                slice = &[];
            }
        }
    }
}

/*

#[interrupt]
fn TG1_T0_LEVEL() {
    critical_section::with(|cs| {
unsafe {
    DAC_PIN_1.borrow_ref_mut(cs).as_mut().unwrap().write(DATA[DATA_I]);
};
    unsafe { DATA_I += 1;
    if DATA_I == DATA_LEN {
        unsafe { DATA_I = 0 };
    }};

        let mut timer = TIMER10.borrow_ref_mut(cs);
        let timer = timer.as_mut().unwrap();

        if timer.is_interrupt_set() {
            timer.clear_interrupt();
            timer.start(1u64.micros());

            unsafe {
                CNT += 1;
                if CNT > 100_000 {
                    CNT = 0;
                    esp_println::println!("Interrupt Level 3 - Timer0");
                }
            }
        }
    });
}
*/